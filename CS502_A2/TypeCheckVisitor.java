//
// Generated by JTB 1.3.2
//

import visitor.*;
import syntaxtree.*;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order. Your visitors may extend this class.
 */
public class TypeCheckVisitor extends GJDepthFirst<String, Map<String, String>> {
   //
   // User-generated visitor methods below
   //

   private int BinOpsErrors;
   private int ConditionErrors;
   private int AssignmentErrors;
   private int FunctionErrors;

   private String currentClass = "";
   private String currentMethod = "";
   private boolean insideMethod = false;
   private ArrayList<String> recordingParams;

   public TypeCheckVisitor() {
      // MetaData.printMetaData();

      BinOpsErrors = 0;
      ConditionErrors = 0;
      AssignmentErrors = 0;
      FunctionErrors = 0;

      recordingParams = new ArrayList<String>();
   }

   private String getType(String value) {
      // if null return null
      // if some defined type, return value
      // if variable stored in current scope
      // else return null
      return MetaData.getVarType(currentClass, currentMethod, value);
   }

   private ArrayList<String> getParents(String key) {
      ArrayList<String> parents = new ArrayList<>();

      String curr = key;
      while (MetaData.inheritanceGraph.containsKey(curr)) {
         String parent = MetaData.inheritanceGraph.get(curr);
         parents.add(parent);
         curr = parent;
      }

      return parents;
   }

   /**
    * Checks if valid type conversion possible
    * @param from - (child)
    * @param to - (parent)
    * @return true if possible
    */
   private boolean isValidTypeCast(String from, String to) {
      from = getType(from);
      to = getType(to);

      // System.out.println(" AFTER: " + from + " : " + "->" + " : " + to);

      if (from == to) {
         return true;
      }

      // we need to check if lhs can take rhs into it
      if (to == "float" && from == "int") {
         return true;
      }

      // Inheritance check
      // lhs can be parent of rhs
      ArrayList<String> parents = getParents(from);
      // System.out.println(parents);
      if (parents.contains(to)) {
         // PRIIYAM - Inheritance part done
         return true;
      }

      return false;
   }

   /**
    * Check if valid binary operation and if yes
    * return the correct type
    */
   private String BinOpsCheck(String type1, String type2, String operand) {
      // System.out.println("BINARY OPS");
      // System.out.println(" BEFORE: " + type1 + " : " + operand + " : " + type2);

      type1 = getType(type1);
      type2 = getType(type2);

      // System.out.println(" AFTER: " + type1 + " : " + operand + " : " + type2);

      if (operand == "+" || operand == "-"
            || operand == "*" || operand == "/") {
         if (type1 == "float" && type2 == "float") {
            return "float";
         } else if (type1 == "float" && type2 == "int") {
            return "float";
         } else if (type1 == "int" && type2 == "float") {
            return "float";
         } else if (type1 == "int" && type2 == "int") {
            return "int";
         }
      }

      if (operand == "&&" || operand == "||") {
         if (type1 == "boolean" && type2 == "boolean") {
            return "boolean";
         }
      }

      if (operand == "<=") {
         if ((type1 == "int" || type1 == "float")
               && (type2 == "int" || type2 == "float")) {
               return "boolean";
         }
      }

      if (operand == "!=") {
         if (type1 == type2) {
            return "boolean";
         }
         else if (type1 == "int" && type2 == "float") {
            return "boolean";
         } else if (type1 == "float" && type2 == "int") {
            return "boolean";
         } else if (isValidTypeCast(type1, type2) || isValidTypeCast(type2, type1)) {
            return "boolean";
         }
      }

      // System.out.println(" ERROR: " + type1 + " : " + operand + " : " + type2);
      BinOpsErrors++;
      return null;
   }

   private void AssignmentOpsCheck(String lhs, String rhs) {
      // System.out.println("ASSIGNMENT OPS");
      // System.out.println("  BEFORE: " + lhs + " : " + "=" + " : " + rhs);

      // rhs to lhs type conversion
      if (isValidTypeCast(rhs, lhs)) {
         return;
      }

      // System.out.println("  ERROR: " + lhs + " : " + "=" + " : " + rhs);
      AssignmentErrors++;
   }

   public String functionCallCheck(String base, String functionName, ArrayList<String> params) {
      // System.out.println("Function call : " + base + " : " + functionName + " : " + params);
      if (base == null) {
         base = currentClass;
      }

      base = getType(base);

      if (base == null) {
         // Variable does not exist, may not have defined
         FunctionErrors++;
         return null;
      }

      ArrayList<String> requiredParams = new ArrayList<String>();
      boolean funExists = false;
      String realBase = base;
      if (MetaData.functionMetadata.get(base).containsKey(functionName)) {
         // Function name exists in this scope
         funExists = true;
         requiredParams = MetaData.functionMetadata.get(base).get(functionName).parameters;
      } else {
         // try finding in one of the parents
         ArrayList<String> parents = getParents(base);
         for(int i = 0; i < parents.size(); i++) {
            if (MetaData.functionMetadata.get(parents.get(i)).containsKey(functionName)) {
               // We found a parent with this function name
               funExists = true;
               realBase = parents.get(i);
               requiredParams = MetaData.functionMetadata.get(parents.get(i)).get(functionName).parameters;
            }
         }
      }

      if (funExists) {
         // System.out.println("Function Params : " + String.valueOf(requiredParams));
         boolean validFunctionCall = true;

         // System.out.println(requiredParams);
         // System.out.println(params);

         if (requiredParams.size() == params.size()) {
            int n = params.size();

            for (int i = 0; i < n; i++) {
               if (isValidTypeCast(params.get(i), requiredParams.get(i))) {
                  continue;
               } else {
                  // System.out.println("YES");
                  validFunctionCall = false;
                  FunctionErrors++; // Each argument matching failure will be a separate Function error
                  // break;
               }
            }
         } else {
            validFunctionCall = false;
         }

         if (validFunctionCall) {
            return MetaData.functionMetadata.get(realBase).get(functionName).returnType;
         }   
      }

      // System.out.println("ERROR : FUNCTION CALL: " + base + " : " + functionName + " : " + params);
      // FunctionErrors++;
      // return null;
      try {
         return MetaData.functionMetadata.get(realBase).get(functionName).returnType;
      } catch(Exception ex) {
         return null;
      }
   }

   /**
    * f0 -> MainClass()
    * f1 -> ( TypeDeclaration() )*
    * f2 -> <EOF>
    */
   public String visit(Goal n, Map<String, String> argu) {
      String _ret = null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);

      System.out.println("Assignment: " + AssignmentErrors);
      System.out.println("Binop: " + BinOpsErrors);
      System.out.println("Control: " + ConditionErrors);
      System.out.println("Function: " + FunctionErrors);

      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> "public"
    * f4 -> "static"
    * f5 -> "void"
    * f6 -> "main"
    * f7 -> "("
    * f8 -> "String"
    * f9 -> "["
    * f10 -> "]"
    * f11 -> Identifier()
    * f12 -> ")"
    * f13 -> "{"
    * f14 -> PrintStatement()
    * f15 -> "}"
    * f16 -> "}"
    */
   public String visit(MainClass n, Map<String, String> argu) {
      String _ret = null;
      n.f0.accept(this, argu);
      currentClass = n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      n.f5.accept(this, argu);
      currentMethod = n.f6.accept(this, argu);
      n.f7.accept(this, argu);
      n.f8.accept(this, argu);
      n.f9.accept(this, argu);
      n.f10.accept(this, argu);
      n.f11.accept(this, argu);
      n.f12.accept(this, argu);
      insideMethod = true;
      n.f13.accept(this, argu);
      n.f14.accept(this, argu);
      n.f15.accept(this, argu);
      insideMethod = false;
      currentMethod = "";
      n.f16.accept(this, argu);
      currentClass = "";
      return _ret;
   }

   /**
    * f0 -> ClassDeclaration()
    * | ClassExtendsDeclaration()
    */
   public String visit(TypeDeclaration n, Map<String, String> argu) {
      String _ret = null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> ( MethodDeclaration() )*
    * f4 -> "}"
    */
   public String visit(ClassDeclaration n, Map<String, String> argu) {
      String _ret = null;
      n.f0.accept(this, argu);
      currentClass = n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      currentClass = "";
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "extends"
    * f3 -> Identifier()
    * f4 -> "{"
    * f5 -> ( MethodDeclaration() )*
    * f6 -> "}"
    */
   public String visit(ClassExtendsDeclaration n, Map<String, String> argu) {
      String _ret = null;
      n.f0.accept(this, argu);
      currentClass = n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      n.f5.accept(this, argu);
      n.f6.accept(this, argu);
      currentClass = "";
      return _ret;
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    * f2 -> ";"
    */
   public String visit(VarDeclaration n, Map<String, String> argu) {
      String _ret = null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "public"
    * f1 -> Type()
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( FormalParameterList() )?
    * f5 -> ")"
    * f6 -> "{"
    * f7 -> ( VarDeclaration() )*
    * f8 -> ( Statement() )*
    * f9 -> "return"
    * f10 -> Expression()
    * f11 -> ";"
    * f12 -> "}"
    */
   public String visit(MethodDeclaration n, Map<String, String> argu) {
      String _ret = null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      currentMethod = n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      n.f5.accept(this, argu);
      n.f6.accept(this, argu);
      insideMethod = true;
      n.f7.accept(this, argu);
      n.f8.accept(this, argu);
      n.f9.accept(this, argu);

      // PRIYAM - Return type check here
      String dynamicReturnType = n.f10.accept(this, argu);
      dynamicReturnType = getType(dynamicReturnType);
      String staticReturnType = MetaData.functionMetadata.get(currentClass).get(currentMethod).returnType;

      if (!isValidTypeCast(dynamicReturnType, staticReturnType)) {
         // PRIYAM - Return type problem
         // System.out.println("ERROR : Return type invalid for function : " + currentMethod);
         FunctionErrors++;
      }

      n.f11.accept(this, argu);
      n.f12.accept(this, argu);
      currentMethod = "";
      insideMethod = false;
      return _ret;
   }

   /**
    * f0 -> FormalParameter()
    * f1 -> ( FormalParameterRest() )*
    */
   public String visit(FormalParameterList n, Map<String, String> argu) {
      String _ret = null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    */
   public String visit(FormalParameter n, Map<String, String> argu) {
      String _ret = null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> FormalParameter()
    */
   public String visit(FormalParameterRest n, Map<String, String> argu) {
      String _ret = null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> BooleanType()
    * | IntegerType()
    * | FloatType()
    * | Identifier()
    */
   public String visit(Type n, Map<String, String> argu) {
      String _ret = null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "boolean"
    */
   public String visit(BooleanType n, Map<String, String> argu) {
      String _ret = null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "int"
    */
   public String visit(IntegerType n, Map<String, String> argu) {
      String _ret = null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "float"
    */
   public String visit(FloatType n, Map<String, String> argu) {
      String _ret = null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Block()
    * | AssignmentStatement()
    * | IfStatement()
    * | WhileStatement()
    * | PrintStatement()
    */
   public String visit(Statement n, Map<String, String> argu) {
      String _ret = null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "{"
    * f1 -> ( Statement() )*
    * f2 -> "}"
    */
   public String visit(Block n, Map<String, String> argu) {
      String _ret = null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "="
    * f2 -> Expression()
    * f3 -> ";"
    */
   public String visit(AssignmentStatement n, Map<String, String> argu) {
      String _ret = null;
      String lhs = n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String rhs = n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      AssignmentOpsCheck(lhs, rhs);
      return _ret;
   }

   /**
    * f0 -> IfthenElseStatement()
    * | IfthenStatement()
    */
   public String visit(IfStatement n, Map<String, String> argu) {
      String _ret = null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public String visit(IfthenStatement n, Map<String, String> argu) {
      String _ret = null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);

      String condType = n.f2.accept(this, argu);
      // System.out.println("CONDTYPE : " + condType);
      if (condType != "boolean") {
         ConditionErrors++;
      }

      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    * f5 -> "else"
    * f6 -> Statement()
    */
   public String visit(IfthenElseStatement n, Map<String, String> argu) {
      String _ret = null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String condType = n.f2.accept(this, argu);

      // System.out.println("CONDTYPE : " + condType);
      if (condType != "boolean") {
         ConditionErrors++;
      }

      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      n.f5.accept(this, argu);
      n.f6.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "while"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public String visit(WhileStatement n, Map<String, String> argu) {
      String _ret = null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String condType = n.f2.accept(this, argu);

      // System.out.println("CONDTYPE : " + condType);
      if (condType != "boolean") {
         ConditionErrors++;
      }

      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "System.out.println"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> ";"
    */
   public String visit(PrintStatement n, Map<String, String> argu) {
      String _ret = null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> OrExpression()
    * | AndExpression()
    * | CompareExpression()
    * | neqExpression()
    * | PlusExpression()
    * | MinusExpression()
    * | TimesExpression()
    * | DivExpression()
    * | MessageSend()
    * | PrimaryExpression()
    */
   public String visit(Expression n, Map<String, String> argu) {
      return n.f0.accept(this, argu);
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "&&"
    * f2 -> PrimaryExpression()
    */
   public String visit(AndExpression n, Map<String, String> argu) {
      String type1 = n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String type2 = n.f2.accept(this, argu);
      return BinOpsCheck(type1, type2, "&&");
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "||"
    * f2 -> PrimaryExpression()
    */
   public String visit(OrExpression n, Map<String, String> argu) {
      String type1 = n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String type2 = n.f2.accept(this, argu);
      return BinOpsCheck(type1, type2, "||");
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "<="
    * f2 -> PrimaryExpression()
    */
   public String visit(CompareExpression n, Map<String, String> argu) {
      String type1 = n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String type2 = n.f2.accept(this, argu);
      return BinOpsCheck(type1, type2, "<=");
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "!="
    * f2 -> PrimaryExpression()
    */
   public String visit(neqExpression n, Map<String, String> argu) {
      String type1 = n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String type2 = n.f2.accept(this, argu);
      return BinOpsCheck(type1, type2, "!=");
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "+"
    * f2 -> PrimaryExpression()
    */
   public String visit(PlusExpression n, Map<String, String> argu) {
      String type1 = n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String type2 = n.f2.accept(this, argu);
      return BinOpsCheck(type1, type2, "+");
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "-"
    * f2 -> PrimaryExpression()
    */
   public String visit(MinusExpression n, Map<String, String> argu) {
      String type1 = n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String type2 = n.f2.accept(this, argu);
      return BinOpsCheck(type1, type2, "-");
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "*"
    * f2 -> PrimaryExpression()
    */
   public String visit(TimesExpression n, Map<String, String> argu) {
      String type1 = n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String type2 = n.f2.accept(this, argu);
      return BinOpsCheck(type1, type2, "*");
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "/"
    * f2 -> PrimaryExpression()
    */
   public String visit(DivExpression n, Map<String, String> argu) {
      String type1 = n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String type2 = n.f2.accept(this, argu);
      return BinOpsCheck(type1, type2, "/");
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( ExpressionList() )?
    * f5 -> ")"
    */
   public String visit(MessageSend n, Map<String, String> argu) {
      // PRIYAM - Function calls
      // First we will check if a valid function call and that function exists or not

      String base = n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String functionName = n.f2.accept(this, argu);

      n.f3.accept(this, argu);
      recordingParams.clear();

      n.f4.accept(this, argu);
      n.f5.accept(this, argu);
      return functionCallCheck(base, functionName, recordingParams);
   }

   /**
    * f0 -> Expression()
    * f1 -> ( ExpressionRest() )*
    */
   public String visit(ExpressionList n, Map<String, String> argu) {
      String _ret = null;
      String firstArgument = n.f0.accept(this, argu);
      recordingParams.add(firstArgument);

      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> Expression()
    */
   public String visit(ExpressionRest n, Map<String, String> argu) {
      n.f0.accept(this, argu);
      String argument = n.f1.accept(this, argu);
      recordingParams.add(argument);

      return argument;
   }

   /**
    * f0 -> IntegerLiteral()
    * | FloatLiteral()
    * | TrueLiteral()
    * | FalseLiteral()
    * | Identifier()
    * | ThisExpression()
    * | AllocationExpression()
    * | NotExpression()
    * | BracketExpression()
    */
   public String visit(PrimaryExpression n, Map<String, String> argu) {
      return n.f0.accept(this, argu);
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public String visit(IntegerLiteral n, Map<String, String> argu) {
      return "int";
   }

   /**
    * f0 -> <FLOAT_LITERAL>
    */
   public String visit(FloatLiteral n, Map<String, String> argu) {
      return "float";
   }

   /**
    * f0 -> "true"
    */
   public String visit(TrueLiteral n, Map<String, String> argu) {
      return "boolean";
   }

   /**
    * f0 -> "false"
    */
   public String visit(FalseLiteral n, Map<String, String> argu) {
      return "boolean";
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public String visit(Identifier n, Map<String, String> argu) {
      return n.f0.tokenImage;
   }

   /**
    * f0 -> "this"
    */
   public String visit(ThisExpression n, Map<String, String> argu) {
      return currentClass;
   }

   /**
    * f0 -> "new"
    * f1 -> Identifier()
    * f2 -> "("
    * f3 -> ")"
    */
   public String visit(AllocationExpression n, Map<String, String> argu) {
      n.f0.accept(this, argu);
      String identifier = n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      return identifier;
   }

   /**
    * f0 -> "!"
    * f1 -> Expression()
    */
   public String visit(NotExpression n, Map<String, String> argu) {
      n.f0.accept(this, argu);
      return n.f1.accept(this, argu);
   }

   /**
    * f0 -> "("
    * f1 -> Expression()
    * f2 -> ")"
    */
   public String visit(BracketExpression n, Map<String, String> argu) {
      n.f0.accept(this, argu);
      String expression = n.f1.accept(this, argu);
      n.f2.accept(this, argu);

      // PRIYAM -> simply ignore the bracket
      return expression;
   }

   /**
    * f0 -> Identifier()
    * f1 -> ( IdentifierRest() )*
    */
   public String visit(IdentifierList n, Map<String, String> argu) {
      String _ret = null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> Identifier()
    */
   public String visit(IdentifierRest n, Map<String, String> argu) {
      String _ret = null;
      n.f0.accept(this, argu);
      return n.f1.accept(this, argu);
   }
}
